<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ™ºèƒ½éª‘è¡ŒåŠ©ç† - OSRM å¢å¼ºç‰ˆ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #e0f7fa, #b2ebf2); color: #333; }
        h1 { text-align: center; color: #0277bd; margin-bottom: 10px; }
        #info { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 20px; }
        #mode-tabs { display: flex; background: #f5f5f5; border-radius: 8px; overflow: hidden; margin-bottom: 15px; }
        .tab-btn { flex: 1; padding: 12px; background: #e3f2fd; border: none; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .tab-btn.active { background: #0277bd; color: white; }
        .tab-content { display: none; padding: 15px; background: white; border-radius: 8px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05); }
        .tab-content.active { display: block; }
        .mode-desc { font-style: italic; color: #555; margin-bottom: 10px; padding: 10px; background: #f0f8ff; border-left: 4px solid #0277bd; border-radius: 4px; }
        button { margin: 5px; padding: 10px 15px; background: #4fc3f7; border: none; border-radius: 5px; color: white; cursor: pointer; font-weight: bold; transition: background 0.3s; }
        button:hover:not(:disabled) { background: #0298cf; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #container { display: flex; gap: 20px; }
        #map { flex: 1; height: 600px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); order: 1; }
        #directions { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); flex: 0 0 300px; height: 600px; overflow-y: auto; order: 2; }
        #directions h3 { margin-top: 0; color: #0277bd; }
        #directions ul { list-style: none; padding: 0; }
        #directions li { margin: 10px 0; padding: 12px; background: #f9f9f9; border: 1px solid #ddd; border-radius: 5px; cursor: pointer; transition: background 0.3s; }
        #directions li:hover { background: #e3f2fd; }
        .directions-header { font-weight: bold; color: #0277bd; }
        #comparison { margin-top: 15px; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background: #e3f2fd; }
        label { margin-left: 10px; font-weight: bold; }
        #routeInfo, #status { font-weight: bold; color: #0277bd; margin: 10px 0; }
        @media (max-width: 768px) { #container { flex-direction: column; } #map, #directions { height: 400px; flex: none; } }
    </style>
</head>
<body>
    <h1>ğŸš´â€â™‚ï¸ æ™ºèƒ½éª‘è¡ŒåŠ©ç†ï¼ˆåŸºäº OSRMï¼‰</h1>
    <div id="info">
        <p style="text-align: center; font-size: 1.1em;">ç‚¹å‡»åœ°å›¾æ·»åŠ ç‚¹ä½ï¼ˆæœ€å¤š8ä¸ªï¼‰ã€‚æ‹–æ‹½è°ƒæ•´ä½ç½®ã€‚é€‰æ‹©æ¨¡å¼å¼€å§‹è§„åˆ’ï¼</p>
        
        <!-- æ¨¡å¼åˆ‡æ¢æ ‡ç­¾é¡µ -->
        <div id="mode-tabs">
            <button class="tab-btn active" onclick="switchMode('manual')">æ‰‹åŠ¨æ¨¡å¼ï¼ˆè‡ªå®šä¹‰é¡ºåºï¼‰</button>
            <button class="tab-btn" onclick="switchMode('optimize')">ä¼˜åŒ–æ¨¡å¼ï¼ˆç³»ç»Ÿè§„åˆ’ï¼‰</button>
        </div>
        
        <!-- æ‰‹åŠ¨æ¨¡å¼å†…å®¹ -->
        <div id="manual-content" class="tab-content active">
            <div class="mode-desc">ğŸ“ æ‚¨æ¥å†³å®šç‚¹ä½çš„é¡ºåºï¼šæ·»åŠ ç‚¹åç›´æ¥ç”Ÿæˆè·¯å¾„ï¼ŒæŒ‰ç‚¹å‡»é¡ºåºå›ºå®šã€‚</div>
            <button id="snap-points-manual" onclick="snapPoints()" disabled>å¸é™„åˆ°æœ€è¿‘é“è·¯</button>
            <button id="generate-route-manual" onclick="generateRouteManual()" disabled>ç”Ÿæˆéª‘è¡Œè·¯çº¿ï¼ˆé¡ºåºå›ºå®šï¼‰</button>
            <button onclick="resetWaypoints()">é‡ç½®ç‚¹ä½</button>
        </div>
        
        <!-- ä¼˜åŒ–æ¨¡å¼å†…å®¹ -->
        <div id="optimize-content" class="tab-content">
            <div class="mode-desc">ğŸ¤– ç³»ç»Ÿå¸®æ‚¨è§„åˆ’ï¼šæ·»åŠ ç‚¹åä¼˜åŒ–é¡ºåºï¼Œç”Ÿæˆæœ€çŸ­/æœ€ä¼˜è·¯å¾„ã€‚</div>
            <button id="snap-points-optimize" onclick="snapPoints()" disabled>å¸é™„åˆ°æœ€è¿‘é“è·¯</button>
            <button id="optimize-trip" onclick="optimizeTrip()" disabled>æ™ºèƒ½ä¼˜åŒ–é¡ºåº</button>
            <button id="compare-matrix" onclick="compareMatrix()" disabled>æ¯”è¾ƒè·ç¦»/æ—¶é—´</button>
            <button id="generate-route-optimize" onclick="generateRouteOptimize()" disabled>ç”Ÿæˆæœ€ä¼˜éª‘è¡Œè·¯çº¿</button>
            <button onclick="resetWaypoints()">é‡ç½®ç‚¹ä½</button>
        </div>
        
        <p id="routeInfo">ä¸»è·¯çº¿è·ç¦»: -- ç±³ | ä¸»è·¯çº¿æ—¶é—´: -- ç§’</p>
        <p id="status">çŠ¶æ€: é€‰æ‹©æ¨¡å¼å¹¶ç‚¹å‡»åœ°å›¾æ·»åŠ èµ·ç‚¹ã€‚</p>
        <div id="comparison"></div>
    </div>
    
    <!-- å·¦å³å¸ƒå±€å®¹å™¨ -->
    <div id="container">
        <div id="map"></div>
        <div id="directions">
            <h3>éª‘è¡Œæ­¥æ­¥æŒ‡å¯¼</h3>
            <div id="directions-content">è¯·æ·»åŠ ç‚¹ä½å¹¶ç”Ÿæˆè·¯çº¿ä»¥æŸ¥çœ‹è¯¦ç»†æ­¥æ­¥æŒ‡ç¤ºã€‚ç‚¹å‡»æ­¥éª¤å¯åœ¨åœ°å›¾ä¸Šé«˜äº®è½¬å‘èŠ‚ç‚¹ã€‚</div>
        </div>
    </div>

    <script>
        // åˆå§‹åŒ–åœ°å›¾ï¼ˆéª‘è¡Œä¸­å¿ƒç¤ºä¾‹ï¼šç æµ·ï¼‰
        const map = L.map('map').setView([22.0636, 113.2834], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // OSRM æœåŠ¡ç«¯ç‚¹
        const osrmBase = 'http://localhost:5000';
        let waypoints = [];
        let routeLayers = [];
        let allSteps = [];
        let highlightMarker = null;
        let optimizedWaypoints = [];
        let currentMode = 'manual';  // é»˜è®¤æ‰‹åŠ¨æ¨¡å¼

        // ç¿»è¯‘æ˜ å°„
        const modifierMap = {
            'left': 'å·¦',
            'right': 'å³',
            'straight': 'ç›´è¡Œ',
            'slight left': 'è½»å¾®å·¦',
            'slight right': 'è½»å¾®å³',
            'sharp left': 'æ€¥å·¦',
            'sharp right': 'æ€¥å³',
            'uturn': 'æ‰å¤´'
        };

        const typeMap = {
            'new name': 'é“è·¯åç§°å˜æ›´',
            'notification': 'é€šçŸ¥'
        };

        // ç¿»è¯‘å‡½æ•°
        function translateModifier(modifier) {
            return modifierMap[modifier] || modifier;
        }

        function translateType(type) {
            return typeMap[type] || type;
        }

        // åŸºæœ¬æŒ‡ä»¤ç”Ÿæˆå‡½æ•°ï¼ˆä¼˜åŒ–ï¼šå…¨ä¸­æ–‡æŒ‡ä»¤ï¼‰
        function getInstruction(step) {
            const maneuver = step.maneuver;
            const name = step.name || 'é“è·¯';
            let instruction = '';

            // éª‘è¡Œç‰¹å®šï¼šå¡åº¦æç¤º
            const elevation = step.elevation_change || 0;
            const elevNote = elevation > 50 ? 'ï¼ˆä¸Šå¡ +50mï¼‰' : elevation < -50 ? 'ï¼ˆä¸‹å¡ -50mï¼‰' : '';

            const mod = translateModifier(maneuver.modifier || '');
            const typ = translateType(maneuver.type);

            switch (maneuver.type) {
                case 'depart':
                    instruction = `ä»${name}å‡ºå‘ï¼Œå‘${mod}æ–¹å‘${elevNote}`;
                    break;
                case 'arrive':
                    instruction = `æ‚¨å·²åˆ°è¾¾ç›®çš„åœ°${elevNote}`;
                    break;
                case 'turn':
                    instruction = `å‘${mod}è½¬å¼¯è¿›å…¥${name}${elevNote}`;
                    break;
                case 'left':
                case 'right':
                case 'sharp left':
                case 'sharp right':
                case 'slight left':
                case 'slight right':
                    const dir = maneuver.type.includes('left') ? 'å·¦' : 'å³';
                    const intensity = maneuver.type.includes('sharp') ? 'æ€¥' : maneuver.type.includes('slight') ? 'è½»å¾®' : '';
                    instruction = `${intensity}${dir}è½¬å¼¯è¿›å…¥${name}${elevNote}`;
                    break;
                case 'use lane':
                    instruction = `ç»§ç»­æ²¿${mod}è½¦é“è¡Œé©¶${name}${elevNote}`;
                    break;
                case 'continue':
                    instruction = `ç»§ç»­è¡Œé©¶è¿›å…¥${name}${elevNote}`;
                    break;
                case 'merge':
                    instruction = `æ±‡å…¥${name}${elevNote}`;
                    break;
                case 'fork':
                    instruction = `åœ¨å²”è·¯å£å‘${mod}ä¿æŒè¿›å…¥${name}${elevNote}`;
                    break;
                case 'name change':
                case 'new name':
                    instruction = `é“è·¯åç§°å˜æ›´ï¼Œç»§ç»­${mod}è¿›å…¥${name}${elevNote}`;
                    break;
                case 'notification':
                    instruction = `${maneuver.instruction || typ}${elevNote}`;
                    break;
                case 'off ramp':
                    instruction = `é©¶å‡º${mod}åŒé“è¿›å…¥${name}${elevNote}`;
                    break;
                case 'on ramp':
                    instruction = `é©¶å…¥åŒé“è¿›å…¥${name}${elevNote}`;
                    break;
                case 'rotary':
                case 'roundabout':
                    instruction = `åœ¨ç¯å²›${maneuver.exit ? `ç¬¬${maneuver.exit}ä¸ª` : 'ç¬¬ä¸€ä¸ª'}å‡ºå£è¿›å…¥${name}${elevNote}`;
                    break;
                case 'end of road':
                    instruction = `ç›®çš„åœ°ä½äº${mod}é“è·¯å°½å¤´${elevNote}`;
                    break;
                default:
                    instruction = `æ‰§è¡Œ${typ}${mod ? ' ' + mod : ''}${elevNote}`;
            }
            return instruction;
        }

        // é«˜äº®æ­¥éª¤èŠ‚ç‚¹ï¼ˆä¿æŒåŸæ ·ï¼‰
        function highlightStep(stepIndex) {
            const step = allSteps[stepIndex];
            if (!step) return;
            const location = step.maneuver.location;
            if (!location || location.length < 2) return;
            const latLng = L.latLng(location[1], location[0]);
            if (highlightMarker) map.removeLayer(highlightMarker);
            highlightMarker = L.circleMarker(latLng, { radius: 8, color: 'yellow', fillColor: 'yellow', fillOpacity: 0.8 })
                .addTo(map).bindPopup(`éª‘è¡Œè½¬å‘: ${getInstruction(step)}`);
            map.flyTo(latLng, 16);
            document.querySelectorAll('#directions-content li').forEach((li, idx) => {
                li.style.backgroundColor = idx === stepIndex ? '#ffff99' : '#f9f9f9';
            });
        }

        // ç”Ÿæˆæ­¥æ­¥æŒ‡å¯¼ HTMLï¼ˆä¿æŒåŸæ ·ï¼‰
        function generateDirections(route) {
            allSteps = route.legs.flatMap(leg => leg.steps);
            let html = `<div class="directions-header">éª‘è¡Œèµ·ç‚¹åˆ°ç»ˆç‚¹</div>
                        <p>${Math.round(route.distance / 1000)} km, ${Math.round(route.duration / 60)} min</p>
                        <ul>`;
            allSteps.forEach((step, index) => {
                const instruction = getInstruction(step);
                const distance = Math.round(step.distance);
                html += `<li id="step-${index}" onclick="highlightStep(${index})">${instruction}<br>${distance} ç±³</li>`;
            });
            html += '</ul>';
            document.getElementById('directions-content').innerHTML = html;
        }

        // æ·»åŠ æ ‡è®°ï¼ˆä¼˜åŒ–ï¼šæ”¯æŒé¡ºåºæ ‡ç­¾ï¼‰
        function addMarker(latlng, text = 'ç‚¹', color = 'blue', order = null) {
            let html = `<div style="background-color:${color}; width:20px; height:20px; border-radius:50%; border:2px solid white; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:12px; color:white;">${order || ''}</div>`;
            return L.marker(latlng, {
                icon: L.divIcon({
                    html: html,
                    className: 'custom-div-icon',
                    iconSize: [20, 20]
                })
            }).addTo(map).bindPopup(text).on('dragend', function() {
                const idx = waypoints.findIndex(w => w.equals(this.getLatLng()));
                if (idx !== -1) waypoints[idx] = this.getLatLng();
                updateStatus('ç‚¹ä½å·²è°ƒæ•´ï¼Œè¯·é‡æ–°ç”Ÿæˆè·¯çº¿ã€‚');
            });
        }

        // æ¨¡å¼åˆ‡æ¢
        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(mode + '-content').classList.add('active');
            // ç¦ç”¨æ‰€æœ‰æŒ‰é’®ï¼Œç­‰å¾…é‡æ–°æ·»åŠ ç‚¹
            disableAllButtons();
            updateStatus(`å·²åˆ‡æ¢åˆ°${mode === 'manual' ? 'æ‰‹åŠ¨æ¨¡å¼' : 'ä¼˜åŒ–æ¨¡å¼'}ï¼Œè¯·ç‚¹å‡»åœ°å›¾æ·»åŠ èµ·ç‚¹ã€‚`);
        }

        // ç¦ç”¨æ‰€æœ‰æŒ‰é’®
        function disableAllButtons() {
            document.querySelectorAll('button[id]').forEach(btn => btn.disabled = true);
        }

        // 1. Nearest æœåŠ¡ï¼šå¸é™„ç‚¹åˆ°æœ€è¿‘è‡ªè¡Œè½¦é“ï¼ˆä¿®æ”¹ï¼šæ·»åŠ é¡ºåºæ ‡ç­¾ï¼‰
        async function snapPoints() {
            if (waypoints.length === 0) { updateStatus('è¯·å…ˆæ·»åŠ ç‚¹ä½ï¼'); return; }
            updateStatus('æ­£åœ¨å¸é™„åˆ°æœ€è¿‘é“è·¯...');
            let snappedPoints = [];
            for (let wp of waypoints) {
                const coords = `${wp.lng},${wp.lat}`;
                const url = `${osrmBase}/nearest/v1/bike/${coords}?number=1`;
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.waypoints && data.waypoints.length > 0) {
                        const snapped = data.waypoints[0].location;
                        snappedPoints.push(L.latLng(snapped[1], snapped[0]));
                    } else {
                        snappedPoints.push(wp);
                    }
                } catch (error) {
                    console.error('Nearest å¤±è´¥:', error);
                    snappedPoints.push(wp);
                }
            }
            map.eachLayer(layer => { if (layer instanceof L.Marker) map.removeLayer(layer); });
            waypoints = snappedPoints;
            waypoints.forEach((w, i) => {
                const orderNum = i + 1;
                const color = currentMode === 'optimize' ? `hsl(${i * 45}, 70%, 50%)` : 'blue';
                addMarker(w, `ç‚¹ ${orderNum}`, color, orderNum);
            });
            enableModeButtons();
            updateStatus('ç‚¹ä½å·²å¸é™„åˆ°æœ€è¿‘è‡ªè¡Œè½¦é“ï¼');
        }

        // 2. Trip æœåŠ¡ï¼šä¼˜åŒ–å¤šç‚¹é¡ºåºï¼ˆä¿®æ”¹ï¼šæ·»åŠ é¡ºåºæ ‡ç­¾ï¼‰
        async function optimizeTrip() {
            if (waypoints.length < 3 || waypoints.length > 8) { updateStatus('ä¼˜åŒ–éœ€ 3-8 ä¸ªç‚¹ä½ï¼'); return; }
            updateStatus('æ­£åœ¨ä¼˜åŒ–è¡Œç¨‹é¡ºåº...');
            const coords = waypoints.map(w => `${w.lng},${w.lat}`).join(';');
            const url = `${osrmBase}/trip/v1/bike/${coords}?source=first&roundtrip=false`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.waypoints && data.waypoints.length > 0 && data.trips && data.trips.length > 0) {
                    const filteredWaypoints = data.waypoints.filter(wp => wp.trips_index === 0);
                    optimizedWaypoints = filteredWaypoints.sort((a, b) => a.waypoint_index - b.waypoint_index)
                        .map(wp => L.latLng(wp.location[1], wp.location[0]));
                    map.eachLayer(layer => { if (layer instanceof L.Marker) map.removeLayer(layer); });
                    optimizedWaypoints.forEach((w, i) => {
                        const orderNum = i + 1;
                        addMarker(w, `ä¼˜åŒ–ç‚¹ ${orderNum}`, `hsl(${i * 45}, 70%, 50%)`, orderNum);
                    });
                    updateStatus(`è¡Œç¨‹å·²ä¼˜åŒ–ï¼æ–°é¡ºåºï¼š${optimizedWaypoints.map((_, i) => i + 1).join(' -> ')}ã€‚`);
                    document.getElementById('compare-matrix').disabled = false;
                    document.getElementById('generate-route-optimize').disabled = false;
                } else {
                    updateStatus('ä¼˜åŒ–å¤±è´¥ï¼šOSRM /trip æœªè¿”å›æœ‰æ•ˆæ•°æ®ã€‚');
                }
            } catch (error) {
                console.error('Trip å¤±è´¥:', error);
                updateStatus('ä¼˜åŒ–å¤±è´¥ï¼š' + error.message);
            }
        }

        // 3. Table æœåŠ¡ï¼šç”ŸæˆçŸ©é˜µï¼ˆä¿æŒåŸæ ·ï¼‰
        async function compareMatrix() {
            if (optimizedWaypoints.length < 2) { updateStatus('éœ€è‡³å°‘2ä¸ªç‚¹ä½ï¼'); return; }
            updateStatus('æ­£åœ¨è®¡ç®—çŸ©é˜µ...');
            const coords = optimizedWaypoints.map(w => `${w.lng},${w.lat}`).join(';');
            const url = `${osrmBase}/table/v1/bike/${coords}?sources=all&destinations=all`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.durations && data.distances) {
                    let html = '<h4>éª‘è¡ŒçŸ©é˜µæ¯”è¾ƒ (åˆ†é’Ÿ / km)</h4><table><tr><th>ä»/åˆ°</th>';
                    for (let i = 0; i < optimizedWaypoints.length; i++) html += `<th>ç‚¹ ${i+1}</th>`;
                    html += '</tr>';
                    for (let i = 0; i < optimizedWaypoints.length; i++) {
                        html += `<tr><td>ç‚¹ ${i+1}</td>`;
                        for (let j = 0; j < optimizedWaypoints.length; j++) {
                            const time = Math.round(data.durations[i][j] / 60);
                            const dist = Math.round(data.distances[i][j] / 1000);
                            html += `<td>${time} min<br>${dist} km</td>`;
                        }
                        html += '</tr>';
                    }
                    html += '</table>';
                    document.getElementById('comparison').innerHTML = html;
                    updateStatus('çŸ©é˜µæ¯”è¾ƒå·²åŠ è½½ï¼');
                } else {
                    updateStatus('çŸ©é˜µè®¡ç®—å¤±è´¥ã€‚');
                }
            } catch (error) {
                console.error('Table å¤±è´¥:', error);
                updateStatus('çŸ©é˜µå¤±è´¥ï¼š' + error.message);
            }
        }

        // 4. Route æœåŠ¡ï¼šæ‰‹åŠ¨æ¨¡å¼ç”Ÿæˆï¼ˆä½¿ç”¨ç‚¹å‡»é¡ºåºï¼‰
        async function generateRouteManual() {
            if (waypoints.length < 2) { updateStatus('è‡³å°‘éœ€è¦2ä¸ªç‚¹ä½ï¼'); return; }
            updateStatus('ä½¿ç”¨ç‚¹å‡»é¡ºåºç”Ÿæˆéª‘è¡Œè·¯çº¿...');
            const coords = waypoints.map(w => `${w.lng},${w.lat}`).join(';');
            const url = `${osrmBase}/route/v1/bike/${coords}?geometries=geojson&overview=full&alternatives=true&steps=true`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.routes && data.routes.length > 0) {
                    clearRoutes();
                    const numRoutes = Math.min(3, data.routes.length);
                    for (let i = 0; i < numRoutes; i++) {
                        const layerGroup = L.layerGroup().addTo(map);
                        displayRoute(data.routes[i], i, layerGroup);
                        routeLayers.push(layerGroup);
                    }
                    generateDirections(data.routes[0]);
                    updateInfo(data.routes[0]);
                    updateStatus(`å·²ç”Ÿæˆ ${numRoutes} æ¡è·¯çº¿ï¼ˆæ‰‹åŠ¨é¡ºåºï¼‰ã€‚`);
                } else {
                    updateStatus('æœªæ‰¾åˆ°æœ‰æ•ˆè·¯çº¿ã€‚');
                }
            } catch (error) {
                console.error('Route å¤±è´¥:', error);
                updateStatus('ç”Ÿæˆå¤±è´¥ï¼š' + error.message);
            }
        }

        // 5. Route æœåŠ¡ï¼šä¼˜åŒ–æ¨¡å¼ç”Ÿæˆï¼ˆä½¿ç”¨ä¼˜åŒ–é¡ºåºï¼‰
        async function generateRouteOptimize() {
            let usePoints = optimizedWaypoints.length > 0 ? optimizedWaypoints : waypoints;
            if (usePoints.length < 2) { updateStatus('è‡³å°‘éœ€è¦2ä¸ªç‚¹ä½ï¼'); return; }
            updateStatus('ä½¿ç”¨ä¼˜åŒ–é¡ºåºç”Ÿæˆæœ€ä¼˜éª‘è¡Œè·¯çº¿...');
            const coords = usePoints.map(w => `${w.lng},${w.lat}`).join(';');
            const url = `${osrmBase}/route/v1/bike/${coords}?geometries=geojson&overview=full&alternatives=true&steps=true`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.routes && data.routes.length > 0) {
                    clearRoutes();
                    const numRoutes = Math.min(3, data.routes.length);
                    for (let i = 0; i < numRoutes; i++) {
                        const layerGroup = L.layerGroup().addTo(map);
                        displayRoute(data.routes[i], i, layerGroup);
                        routeLayers.push(layerGroup);
                    }
                    generateDirections(data.routes[0]);
                    updateInfo(data.routes[0]);
                    updateStatus(`å·²ç”Ÿæˆ ${numRoutes} æ¡æœ€ä¼˜è·¯çº¿ï¼ˆç³»ç»Ÿè§„åˆ’ï¼‰ã€‚`);
                } else {
                    updateStatus('æœªæ‰¾åˆ°æœ‰æ•ˆè·¯çº¿ã€‚');
                }
            } catch (error) {
                console.error('Route å¤±è´¥:', error);
                updateStatus('ç”Ÿæˆå¤±è´¥ï¼š' + error.message);
            }
        }

        // æ˜¾ç¤ºå•æ¡è·¯çº¿ï¼ˆä¿æŒåŸæ ·ï¼‰
        function displayRoute(route, index, layerGroup) {
            const geoCoords = route.geometry.coordinates.map(c => [c[1], c[0]]);
            const color = `hsl(${index * 120}, 70%, 50%)`;
            L.polyline(geoCoords, {color: color, weight: 5})
                .addTo(layerGroup)
                .bindPopup(`å¤‡é€‰è·¯çº¿ ${index + 1}:<br>è·ç¦»: ${Math.round(route.distance)} ç±³<br>æ—¶é—´: ${Math.round(route.duration)} ç§’`);
        }

        // æ›´æ–°ä¿¡æ¯ï¼ˆä¿æŒåŸæ ·ï¼‰
        function updateInfo(route) {
            document.getElementById('routeInfo').innerHTML = 
                `ä¸»è·¯çº¿è·ç¦»: ${Math.round(route.distance)} ç±³ | ä¸»è·¯çº¿æ—¶é—´: ${Math.round(route.duration)} ç§’`;
        }

        // æ›´æ–°çŠ¶æ€ï¼ˆä¿æŒåŸæ ·ï¼‰
        function updateStatus(msg) {
            document.getElementById('status').innerHTML = `çŠ¶æ€: ${msg}`;
        }

        // å¯ç”¨æ¨¡å¼æŒ‰é’®
        function enableModeButtons() {
            if (currentMode === 'manual') {
                document.getElementById('snap-points-manual').disabled = false;
                if (waypoints.length >= 2) document.getElementById('generate-route-manual').disabled = false;
            } else {
                document.getElementById('snap-points-optimize').disabled = false;
                if (waypoints.length >= 3) {
                    document.getElementById('optimize-trip').disabled = false;
                    document.getElementById('generate-route-optimize').disabled = false;
                }
            }
        }

        // æ¸…ç©ºè·¯çº¿
        function clearRoutes() {
            routeLayers.forEach(layer => map.removeLayer(layer));
            routeLayers = [];
            if (highlightMarker) map.removeLayer(highlightMarker);
        }

        // äº¤äº’ï¼šç‚¹å‡»æ·»åŠ ç‚¹ä½ï¼ˆä¿®æ”¹ï¼šæ·»åŠ é¡ºåºæ ‡ç­¾ï¼‰
        map.on('click', function(e) {
            if (waypoints.length >= 8) { updateStatus('å·²è¾¾æœ€å¤§8ä¸ªç‚¹ä½ï¼'); return; }
            const idx = waypoints.length;
            const text = `ç‚¹ ${idx + 1}`;
            const orderNum = idx + 1;
            const color = currentMode === 'optimize' ? `hsl(${idx * 45}, 70%, 50%)` : 'blue';
            const marker = addMarker(e.latlng, text, color, orderNum);
            waypoints.push(e.latlng);
            updateStatus(`å·²æ·»åŠ ${text}ã€‚ç»§ç»­æ·»åŠ æˆ–ç”Ÿæˆè·¯çº¿ã€‚`);
            enableModeButtons();
            if (waypoints.length >= 3 && currentMode === 'optimize') {
                document.getElementById('optimize-trip').disabled = false;
            }
        });

        // é‡ç½®ç‚¹ä½ï¼ˆä¿æŒåŸæ ·ï¼Œä½†æ·»åŠ æ¸…ç©ºæ¨¡å¼æŒ‰é’®ï¼‰
        function resetWaypoints() {
            map.eachLayer(layer => { if (layer instanceof L.Marker) map.removeLayer(layer); });
            clearRoutes();
            waypoints = [];
            optimizedWaypoints = [];
            allSteps = [];
            disableAllButtons();
            document.getElementById('routeInfo').innerHTML = 'ä¸»è·¯çº¿è·ç¦»: -- ç±³ | ä¸»è·¯çº¿æ—¶é—´: -- ç§’';
            document.getElementById('directions-content').innerHTML = 'è¯·æ·»åŠ ç‚¹ä½å¹¶ç”Ÿæˆè·¯çº¿ä»¥æŸ¥çœ‹è¯¦ç»†æ­¥æ­¥æŒ‡ç¤ºã€‚';
            document.getElementById('comparison').innerHTML = '';
            updateStatus('å·²é‡ç½®ï¼Œè¯·ç‚¹å‡»åœ°å›¾æ·»åŠ èµ·ç‚¹ã€‚');
        }

        // åˆå§‹åŒ–
        updateStatus('é€‰æ‹©æ¨¡å¼å¹¶ç‚¹å‡»åœ°å›¾æ·»åŠ èµ·ç‚¹ã€‚');
    </script>
</body>
</html>